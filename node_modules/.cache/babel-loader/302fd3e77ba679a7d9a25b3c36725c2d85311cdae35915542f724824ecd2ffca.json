{"ast":null,"code":"/*!\n * jQuery UI Autocomplete 1.13.2\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n */\n\n//>>label: Autocomplete\n//>>group: Widgets\n//>>description: Lists suggested words as the user is typing.\n//>>docs: http://api.jqueryui.com/autocomplete/\n//>>demos: http://jqueryui.com/autocomplete/\n//>>css.structure: ../../themes/base/core.css\n//>>css.structure: ../../themes/base/autocomplete.css\n//>>css.theme: ../../themes/base/theme.css\n\n(function (factory) {\n  \"use strict\";\n\n  if (typeof define === \"function\" && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([\"jquery\", \"./menu\", \"../keycode\", \"../position\", \"../safe-active-element\", \"../version\", \"../widget\"], factory);\n  } else {\n    // Browser globals\n    factory(jQuery);\n  }\n})(function ($) {\n  \"use strict\";\n\n  $.widget(\"ui.autocomplete\", {\n    version: \"1.13.2\",\n    defaultElement: \"<input>\",\n    options: {\n      appendTo: null,\n      autoFocus: false,\n      delay: 300,\n      minLength: 1,\n      position: {\n        my: \"left top\",\n        at: \"left bottom\",\n        collision: \"none\"\n      },\n      source: null,\n      // Callbacks\n      change: null,\n      close: null,\n      focus: null,\n      open: null,\n      response: null,\n      search: null,\n      select: null\n    },\n    requestIndex: 0,\n    pending: 0,\n    liveRegionTimer: null,\n    _create: function () {\n      // Some browsers only repeat keydown events, not keypress events,\n      // so we use the suppressKeyPress flag to determine if we've already\n      // handled the keydown event. #7269\n      // Unfortunately the code for & in keypress is the same as the up arrow,\n      // so we use the suppressKeyPressRepeat flag to avoid handling keypress\n      // events when we know the keydown event was used to modify the\n      // search term. #7799\n      var suppressKeyPress,\n        suppressKeyPressRepeat,\n        suppressInput,\n        nodeName = this.element[0].nodeName.toLowerCase(),\n        isTextarea = nodeName === \"textarea\",\n        isInput = nodeName === \"input\";\n\n      // Textareas are always multi-line\n      // Inputs are always single-line, even if inside a contentEditable element\n      // IE also treats inputs as contentEditable\n      // All other element types are determined by whether or not they're contentEditable\n      this.isMultiLine = isTextarea || !isInput && this._isContentEditable(this.element);\n      this.valueMethod = this.element[isTextarea || isInput ? \"val\" : \"text\"];\n      this.isNewMenu = true;\n      this._addClass(\"ui-autocomplete-input\");\n      this.element.attr(\"autocomplete\", \"off\");\n      this._on(this.element, {\n        keydown: function (event) {\n          if (this.element.prop(\"readOnly\")) {\n            suppressKeyPress = true;\n            suppressInput = true;\n            suppressKeyPressRepeat = true;\n            return;\n          }\n          suppressKeyPress = false;\n          suppressInput = false;\n          suppressKeyPressRepeat = false;\n          var keyCode = $.ui.keyCode;\n          switch (event.keyCode) {\n            case keyCode.PAGE_UP:\n              suppressKeyPress = true;\n              this._move(\"previousPage\", event);\n              break;\n            case keyCode.PAGE_DOWN:\n              suppressKeyPress = true;\n              this._move(\"nextPage\", event);\n              break;\n            case keyCode.UP:\n              suppressKeyPress = true;\n              this._keyEvent(\"previous\", event);\n              break;\n            case keyCode.DOWN:\n              suppressKeyPress = true;\n              this._keyEvent(\"next\", event);\n              break;\n            case keyCode.ENTER:\n              // when menu is open and has focus\n              if (this.menu.active) {\n                // #6055 - Opera still allows the keypress to occur\n                // which causes forms to submit\n                suppressKeyPress = true;\n                event.preventDefault();\n                this.menu.select(event);\n              }\n              break;\n            case keyCode.TAB:\n              if (this.menu.active) {\n                this.menu.select(event);\n              }\n              break;\n            case keyCode.ESCAPE:\n              if (this.menu.element.is(\":visible\")) {\n                if (!this.isMultiLine) {\n                  this._value(this.term);\n                }\n                this.close(event);\n\n                // Different browsers have different default behavior for escape\n                // Single press can mean undo or clear\n                // Double press in IE means clear the whole form\n                event.preventDefault();\n              }\n              break;\n            default:\n              suppressKeyPressRepeat = true;\n\n              // search timeout should be triggered before the input value is changed\n              this._searchTimeout(event);\n              break;\n          }\n        },\n        keypress: function (event) {\n          if (suppressKeyPress) {\n            suppressKeyPress = false;\n            if (!this.isMultiLine || this.menu.element.is(\":visible\")) {\n              event.preventDefault();\n            }\n            return;\n          }\n          if (suppressKeyPressRepeat) {\n            return;\n          }\n\n          // Replicate some key handlers to allow them to repeat in Firefox and Opera\n          var keyCode = $.ui.keyCode;\n          switch (event.keyCode) {\n            case keyCode.PAGE_UP:\n              this._move(\"previousPage\", event);\n              break;\n            case keyCode.PAGE_DOWN:\n              this._move(\"nextPage\", event);\n              break;\n            case keyCode.UP:\n              this._keyEvent(\"previous\", event);\n              break;\n            case keyCode.DOWN:\n              this._keyEvent(\"next\", event);\n              break;\n          }\n        },\n        input: function (event) {\n          if (suppressInput) {\n            suppressInput = false;\n            event.preventDefault();\n            return;\n          }\n          this._searchTimeout(event);\n        },\n        focus: function () {\n          this.selectedItem = null;\n          this.previous = this._value();\n        },\n        blur: function (event) {\n          clearTimeout(this.searching);\n          this.close(event);\n          this._change(event);\n        }\n      });\n      this._initSource();\n      this.menu = $(\"<ul>\").appendTo(this._appendTo()).menu({\n        // disable ARIA support, the live region takes care of that\n        role: null\n      }).hide()\n\n      // Support: IE 11 only, Edge <= 14\n      // For other browsers, we preventDefault() on the mousedown event\n      // to keep the dropdown from taking focus from the input. This doesn't\n      // work for IE/Edge, causing problems with selection and scrolling (#9638)\n      // Happily, IE and Edge support an \"unselectable\" attribute that\n      // prevents an element from receiving focus, exactly what we want here.\n      .attr({\n        \"unselectable\": \"on\"\n      }).menu(\"instance\");\n      this._addClass(this.menu.element, \"ui-autocomplete\", \"ui-front\");\n      this._on(this.menu.element, {\n        mousedown: function (event) {\n          // Prevent moving focus out of the text field\n          event.preventDefault();\n        },\n        menufocus: function (event, ui) {\n          var label, item;\n\n          // support: Firefox\n          // Prevent accidental activation of menu items in Firefox (#7024 #9118)\n          if (this.isNewMenu) {\n            this.isNewMenu = false;\n            if (event.originalEvent && /^mouse/.test(event.originalEvent.type)) {\n              this.menu.blur();\n              this.document.one(\"mousemove\", function () {\n                $(event.target).trigger(event.originalEvent);\n              });\n              return;\n            }\n          }\n          item = ui.item.data(\"ui-autocomplete-item\");\n          if (false !== this._trigger(\"focus\", event, {\n            item: item\n          })) {\n            // use value to match what will end up in the input, if it was a key event\n            if (event.originalEvent && /^key/.test(event.originalEvent.type)) {\n              this._value(item.value);\n            }\n          }\n\n          // Announce the value in the liveRegion\n          label = ui.item.attr(\"aria-label\") || item.value;\n          if (label && String.prototype.trim.call(label).length) {\n            clearTimeout(this.liveRegionTimer);\n            this.liveRegionTimer = this._delay(function () {\n              this.liveRegion.html($(\"<div>\").text(label));\n            }, 100);\n          }\n        },\n        menuselect: function (event, ui) {\n          var item = ui.item.data(\"ui-autocomplete-item\"),\n            previous = this.previous;\n\n          // Only trigger when focus was lost (click on menu)\n          if (this.element[0] !== $.ui.safeActiveElement(this.document[0])) {\n            this.element.trigger(\"focus\");\n            this.previous = previous;\n\n            // #6109 - IE triggers two focus events and the second\n            // is asynchronous, so we need to reset the previous\n            // term synchronously and asynchronously :-(\n            this._delay(function () {\n              this.previous = previous;\n              this.selectedItem = item;\n            });\n          }\n          if (false !== this._trigger(\"select\", event, {\n            item: item\n          })) {\n            this._value(item.value);\n          }\n\n          // reset the term after the select event\n          // this allows custom select handling to work properly\n          this.term = this._value();\n          this.close(event);\n          this.selectedItem = item;\n        }\n      });\n      this.liveRegion = $(\"<div>\", {\n        role: \"status\",\n        \"aria-live\": \"assertive\",\n        \"aria-relevant\": \"additions\"\n      }).appendTo(this.document[0].body);\n      this._addClass(this.liveRegion, null, \"ui-helper-hidden-accessible\");\n\n      // Turning off autocomplete prevents the browser from remembering the\n      // value when navigating through history, so we re-enable autocomplete\n      // if the page is unloaded before the widget is destroyed. #7790\n      this._on(this.window, {\n        beforeunload: function () {\n          this.element.removeAttr(\"autocomplete\");\n        }\n      });\n    },\n    _destroy: function () {\n      clearTimeout(this.searching);\n      this.element.removeAttr(\"autocomplete\");\n      this.menu.element.remove();\n      this.liveRegion.remove();\n    },\n    _setOption: function (key, value) {\n      this._super(key, value);\n      if (key === \"source\") {\n        this._initSource();\n      }\n      if (key === \"appendTo\") {\n        this.menu.element.appendTo(this._appendTo());\n      }\n      if (key === \"disabled\" && value && this.xhr) {\n        this.xhr.abort();\n      }\n    },\n    _isEventTargetInWidget: function (event) {\n      var menuElement = this.menu.element[0];\n      return event.target === this.element[0] || event.target === menuElement || $.contains(menuElement, event.target);\n    },\n    _closeOnClickOutside: function (event) {\n      if (!this._isEventTargetInWidget(event)) {\n        this.close();\n      }\n    },\n    _appendTo: function () {\n      var element = this.options.appendTo;\n      if (element) {\n        element = element.jquery || element.nodeType ? $(element) : this.document.find(element).eq(0);\n      }\n      if (!element || !element[0]) {\n        element = this.element.closest(\".ui-front, dialog\");\n      }\n      if (!element.length) {\n        element = this.document[0].body;\n      }\n      return element;\n    },\n    _initSource: function () {\n      var array,\n        url,\n        that = this;\n      if (Array.isArray(this.options.source)) {\n        array = this.options.source;\n        this.source = function (request, response) {\n          response($.ui.autocomplete.filter(array, request.term));\n        };\n      } else if (typeof this.options.source === \"string\") {\n        url = this.options.source;\n        this.source = function (request, response) {\n          if (that.xhr) {\n            that.xhr.abort();\n          }\n          that.xhr = $.ajax({\n            url: url,\n            data: request,\n            dataType: \"json\",\n            success: function (data) {\n              response(data);\n            },\n            error: function () {\n              response([]);\n            }\n          });\n        };\n      } else {\n        this.source = this.options.source;\n      }\n    },\n    _searchTimeout: function (event) {\n      clearTimeout(this.searching);\n      this.searching = this._delay(function () {\n        // Search if the value has changed, or if the user retypes the same value (see #7434)\n        var equalValues = this.term === this._value(),\n          menuVisible = this.menu.element.is(\":visible\"),\n          modifierKey = event.altKey || event.ctrlKey || event.metaKey || event.shiftKey;\n        if (!equalValues || equalValues && !menuVisible && !modifierKey) {\n          this.selectedItem = null;\n          this.search(null, event);\n        }\n      }, this.options.delay);\n    },\n    search: function (value, event) {\n      value = value != null ? value : this._value();\n\n      // Always save the actual value, not the one passed as an argument\n      this.term = this._value();\n      if (value.length < this.options.minLength) {\n        return this.close(event);\n      }\n      if (this._trigger(\"search\", event) === false) {\n        return;\n      }\n      return this._search(value);\n    },\n    _search: function (value) {\n      this.pending++;\n      this._addClass(\"ui-autocomplete-loading\");\n      this.cancelSearch = false;\n      this.source({\n        term: value\n      }, this._response());\n    },\n    _response: function () {\n      var index = ++this.requestIndex;\n      return function (content) {\n        if (index === this.requestIndex) {\n          this.__response(content);\n        }\n        this.pending--;\n        if (!this.pending) {\n          this._removeClass(\"ui-autocomplete-loading\");\n        }\n      }.bind(this);\n    },\n    __response: function (content) {\n      if (content) {\n        content = this._normalize(content);\n      }\n      this._trigger(\"response\", null, {\n        content: content\n      });\n      if (!this.options.disabled && content && content.length && !this.cancelSearch) {\n        this._suggest(content);\n        this._trigger(\"open\");\n      } else {\n        // use ._close() instead of .close() so we don't cancel future searches\n        this._close();\n      }\n    },\n    close: function (event) {\n      this.cancelSearch = true;\n      this._close(event);\n    },\n    _close: function (event) {\n      // Remove the handler that closes the menu on outside clicks\n      this._off(this.document, \"mousedown\");\n      if (this.menu.element.is(\":visible\")) {\n        this.menu.element.hide();\n        this.menu.blur();\n        this.isNewMenu = true;\n        this._trigger(\"close\", event);\n      }\n    },\n    _change: function (event) {\n      if (this.previous !== this._value()) {\n        this._trigger(\"change\", event, {\n          item: this.selectedItem\n        });\n      }\n    },\n    _normalize: function (items) {\n      // assume all items have the right format when the first item is complete\n      if (items.length && items[0].label && items[0].value) {\n        return items;\n      }\n      return $.map(items, function (item) {\n        if (typeof item === \"string\") {\n          return {\n            label: item,\n            value: item\n          };\n        }\n        return $.extend({}, item, {\n          label: item.label || item.value,\n          value: item.value || item.label\n        });\n      });\n    },\n    _suggest: function (items) {\n      var ul = this.menu.element.empty();\n      this._renderMenu(ul, items);\n      this.isNewMenu = true;\n      this.menu.refresh();\n\n      // Size and position menu\n      ul.show();\n      this._resizeMenu();\n      ul.position($.extend({\n        of: this.element\n      }, this.options.position));\n      if (this.options.autoFocus) {\n        this.menu.next();\n      }\n\n      // Listen for interactions outside of the widget (#6642)\n      this._on(this.document, {\n        mousedown: \"_closeOnClickOutside\"\n      });\n    },\n    _resizeMenu: function () {\n      var ul = this.menu.element;\n      ul.outerWidth(Math.max(\n      // Firefox wraps long text (possibly a rounding bug)\n      // so we add 1px to avoid the wrapping (#7513)\n      ul.width(\"\").outerWidth() + 1, this.element.outerWidth()));\n    },\n    _renderMenu: function (ul, items) {\n      var that = this;\n      $.each(items, function (index, item) {\n        that._renderItemData(ul, item);\n      });\n    },\n    _renderItemData: function (ul, item) {\n      return this._renderItem(ul, item).data(\"ui-autocomplete-item\", item);\n    },\n    _renderItem: function (ul, item) {\n      return $(\"<li>\").append($(\"<div>\").text(item.label)).appendTo(ul);\n    },\n    _move: function (direction, event) {\n      if (!this.menu.element.is(\":visible\")) {\n        this.search(null, event);\n        return;\n      }\n      if (this.menu.isFirstItem() && /^previous/.test(direction) || this.menu.isLastItem() && /^next/.test(direction)) {\n        if (!this.isMultiLine) {\n          this._value(this.term);\n        }\n        this.menu.blur();\n        return;\n      }\n      this.menu[direction](event);\n    },\n    widget: function () {\n      return this.menu.element;\n    },\n    _value: function () {\n      return this.valueMethod.apply(this.element, arguments);\n    },\n    _keyEvent: function (keyEvent, event) {\n      if (!this.isMultiLine || this.menu.element.is(\":visible\")) {\n        this._move(keyEvent, event);\n\n        // Prevents moving cursor to beginning/end of the text field in some browsers\n        event.preventDefault();\n      }\n    },\n    // Support: Chrome <=50\n    // We should be able to just use this.element.prop( \"isContentEditable\" )\n    // but hidden elements always report false in Chrome.\n    // https://code.google.com/p/chromium/issues/detail?id=313082\n    _isContentEditable: function (element) {\n      if (!element.length) {\n        return false;\n      }\n      var editable = element.prop(\"contentEditable\");\n      if (editable === \"inherit\") {\n        return this._isContentEditable(element.parent());\n      }\n      return editable === \"true\";\n    }\n  });\n  $.extend($.ui.autocomplete, {\n    escapeRegex: function (value) {\n      return value.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, \"\\\\$&\");\n    },\n    filter: function (array, term) {\n      var matcher = new RegExp($.ui.autocomplete.escapeRegex(term), \"i\");\n      return $.grep(array, function (value) {\n        return matcher.test(value.label || value.value || value);\n      });\n    }\n  });\n\n  // Live region extension, adding a `messages` option\n  // NOTE: This is an experimental API. We are still investigating\n  // a full solution for string manipulation and internationalization.\n  $.widget(\"ui.autocomplete\", $.ui.autocomplete, {\n    options: {\n      messages: {\n        noResults: \"No search results.\",\n        results: function (amount) {\n          return amount + (amount > 1 ? \" results are\" : \" result is\") + \" available, use up and down arrow keys to navigate.\";\n        }\n      }\n    },\n    __response: function (content) {\n      var message;\n      this._superApply(arguments);\n      if (this.options.disabled || this.cancelSearch) {\n        return;\n      }\n      if (content && content.length) {\n        message = this.options.messages.results(content.length);\n      } else {\n        message = this.options.messages.noResults;\n      }\n      clearTimeout(this.liveRegionTimer);\n      this.liveRegionTimer = this._delay(function () {\n        this.liveRegion.html($(\"<div>\").text(message));\n      }, 100);\n    }\n  });\n  return $.ui.autocomplete;\n});","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}